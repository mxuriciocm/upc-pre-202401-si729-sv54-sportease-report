# Capítulo 5: Product Implementation, Validation & Deployment

## 5.1 Software Configuration Management.

Para la gestión de la configuración de software de nuestra aplicación nos enfocaremos en la Gestión de Código Fuente, donde controlaremos las versiones y estableceremos una estructura organizada para el código; la Configuración del Entorno de Desarrollo, aquí nos aseguramos que todos los miembros del equipo tengan herramientas consistentes y la Configuración de Despliegue, que aborda el despliegue en entornos de producción. Esta toma de decisiones garantiza la coherencia y eficiencia a lo largo del ciclo de vida de la aplicación, lo que es necesario para cumplir con nuestra misión de ofrecer a estudiantes, instructores y administradores optimizar sus actividades académicas deportivas.

### 5.1.1 Software Development Environment Configuration

En esta sección nuestro equipo de trabajo va a especificar, describir e indicar los nombres de productos, el propósito de uso en el proyecto, la ruta de referencia (para software basado en modelos SaaS) o ruta de descarga (para productos que se ejecutan en el computador del miembro del equipo) de cada uno de los productos de software que deben utilizar los miembros del equipo para colaborar en el ciclo de vida del producto digital.

#### Project Management:

Esta sección respecta a la organización y control del proyecto durante todo su ciclo de vida en el sentido de control del personal que trabaja en este, junto a sus acciones y colaboraciones a lo largo del tiempo y a sus asignaciones ya estipuladas. Ante esto, hemos separado esta sección entre puntos distintos que funcionan como distintos métodos de comunicación y gestión del equipo de trabajo.

**Reuniones de Trabajo:** En cuanto a la organización de las reuniones para nuestro equipo de trabajo, hemos llegado a una decisión unánime sobre los medios de videoconferencia más adecuados: hemos optado por utilizar tanto la aplicación "Discord" como "Google Meet". Esta elección se basa en varios factores que consideramos importantes para garantizar reuniones eficientes y productivas.

En primer lugar, "Discord" ha sido seleccionado por su accesibilidad y familiaridad para todos los miembros del equipo. Todos estamos familiarizados con esta plataforma, lo que facilita la comunicación y el acceso a las reuniones de manera rápida y sencilla. Aunque Discord puede carecer de algunas herramientas avanzadas presentes en otras aplicaciones de videoconferencia, su interfaz simple y directa nos permite mantener una comunicación eficiente sin complicaciones. Además, su flexibilidad en cuanto a la duración de las reuniones, al no tener límites de tiempo, nos brinda la libertad de discutir temas en profundidad sin interrupciones.

- Página oficial de Discord: https://discord.com/ 

Por otro lado, "Google Meet" ha sido seleccionado por su conjunto de características que complementan nuestras necesidades durante las videoconferencias. A pesar de algunas limitaciones en cuanto a la grabación de reuniones, Google Meet ofrece herramientas útiles como el intercambio de pantalla, el chat directo y la función de pizarra, que son esenciales para colaborar y compartir información de manera efectiva durante las reuniones de larga duración. Estas características adicionales compensan las limitaciones y hacen que Google Meet sea una opción sólida para nuestras necesidades de videoconferencia.

- Página oficial de Google Meet: https://meet.google.com/

**Control de Versiones:** Con respecto al control de versiones que presentara nuestro equipo de trabajo, nuestro grupo a utilizado las propias herramientas de "Github" dentro de la organización de todo el proyecto. A través del uso de commits y pull request, cada miembro del equipo puede apoyar en el desarrollo y, a través del historial, revisar las antiguas versiones antes de los cambios propuestos.

- Página oficial de Github: https://github.com/

---

#### Requirements Management:

Esta sección respecta a la organización eficiente del trabajo de cada miembro del equipo con tareas y modelos ya estipulados para cada sección del trabajo que les sea respectiva. De esta forma podemos seguir el rendimiento y desempeño de cada miembro del equipo de trabajo, junto a las funciones que cumplieron adecuadamente.

Para garantizar una organización eficiente del trabajo de cada miembro del equipo, hemos optado por utilizar herramientas específicas que faciliten la asignación de tareas, el seguimiento del progreso y la gestión de los requisitos y requerimientos del proyecto.

En primer lugar, hemos integrado la aplicación web "Trello" en nuestra metodología de trabajo. Trello proporciona una interfaz intuitiva que permite la separación clara de actividades entre varios miembros del equipo. Mediante la creación de tableros personalizados y la asignación de tarjetas a cada tarea, podemos definir fechas límite, asignar responsables y seguir el estado de cada actividad de manera efectiva. Esto nos permite medir rápidamente el progreso en relación con los requisitos y requerimientos del proyecto. Además, Trello nos brinda la capacidad de revisar el rendimiento en conjunto y las actividades realizadas por cada usuario, lo que fomenta la transparencia y la colaboración dentro del equipo.

- Página oficial de Trello: https://trello.com/es

Además de Trello, hemos incorporado la aplicación "PivotalTracker" en nuestro proceso de organización del trabajo. PivotalTracker utiliza un enfoque centrado en el Product Backlog, permitiéndonos crear y gestionar historias de usuario y tareas de manera centralizada. Esta herramienta nos proporciona notas detalladas sobre las actividades realizadas por cada miembro del equipo en cada sección del backlog, lo que nos permite mantener un registro claro de los avances y contribuciones individuales. Además, PivotalTracker utiliza medidas de rendimiento conjunto para evaluar el progreso general del proyecto y garantizar que se cumplan los objetivos establecidos.

- Página oficial de PivotalTracker: https://www.pivotaltracker.com/ 

---

#### Product UX/UI Design:

Esta sección respecta al desarrollo y diseñado de las secciones basadas en el UX y UI correspondientes a nuestro proyecto durante todo su ciclo de vida. Las herramientas utilizadas deben estar compuestas de varias aplicaciones con estilos varios que permitan modificar la estetica de todas las páginas que vamos a programar y como estas se verían para nuestros clientes finales, siguiendo las historias de usuario y toda metodologia de desarrollo web. Asimismo, estas herramientas también deben permitir la estructuración y diagramación de todas las tablas y organizadores necesarios.

**Mapas y User Personas:** En relación al diseño de los diagramas relacionados con el seguimiento de mapas, como el Empathy Map, el Journey Map y el Impact Map, hemos llegado a la conclusión unánime de que la plataforma "UXPressia" es la opción más adecuada para llevar a cabo esta tarea. Esta decisión se basa en varios aspectos que consideramos esenciales para un diseño eficaz y colaborativo.

"UXPressia" se destaca por ofrecer un estilo de diseño más cómodo y amigable en comparación con otras aplicaciones disponibles en el mercado. Su interfaz intuitiva y sus herramientas integradas facilitan la creación de mapas con seguimientos de manera rápida y precisa. Además, la plataforma permite el desarrollo colaborativo, lo que nos permite trabajar en equipo de manera eficiente y coordinada, garantizando la coherencia y la calidad de nuestros mapas.

En cuanto al diseño de User Personas para cada segmento objetivo identificado para nuestra startup y producto, también hemos optado por utilizar la plataforma "UXPressia". Aunque reconocemos que otras herramientas pueden ofrecer características más avanzadas, encontramos que "UXPressia" proporciona modelos predefinidos y formatos agradables que nos permiten crear User Personas de manera efectiva y visualmente atractiva. Aunque puede haber algunas limitaciones en el desarrollo de gráficos grandes y diagramas complejos, las características y la usabilidad general de la plataforma compensan estos aspectos.

- Página oficial de UXPressia: https://uxpressia.com/ 

**Escenarios:** Para la realización de escenarios correspondientes al AS-IS y TO-BE para nuestros segmentos de mercado ya diseñados, hemos utilizado la aplicación web de "Miro", la cual es una herramienta muy versátil que ofrece una amplia gama de funcionalidades para el modelado de escenarios AS-IS y TO-BE, así como para el mapeo de todo el camino de acciones que realiza el cliente. Su variedad de plantillas y modelos facilita la creación de tablas y diagramas de manera efectiva y visualmente atractiva.

Además, la capacidad de trabajo colaborativo de Miro es una ventaja significativa, ya que permite que varios miembros del equipo contribuyan en tiempo real al desarrollo y refinamiento de los escenarios y tablas. Esta función fomenta la colaboración y la participación activa de todo el equipo, lo que puede conducir a una mayor calidad en los resultados finales. La interfaz cómoda y sencilla de manipular de Miro también es un punto a favor, ya que facilita la navegación y el uso de la herramienta, lo que permite a los usuarios concentrarse en la tarea de modelado sin distracciones innecesarias.

- Página oficial de Miro: https://miro.com/ 

**Wireframes, Mock-ups y Prototypes:** Para abordar el diseño de los wireframes, mock-ups y prototipos relacionados con la landing page de nuestra startup y todas las pestañas de la aplicación web respectiva al frontend, nuestro equipo ha tomado la decisión unánime de utilizar la plataforma "Figma". Esta elección se basa en varios factores clave que consideramos fundamentales para garantizar un proceso de diseño eficiente y efectivo. Figma es una herramienta especializada en el diseño de aplicaciones y páginas web que ofrece una amplia gama de funcionalidades diseñadas específicamente para satisfacer las necesidades de los diseñadores y desarrolladores de productos digitales. Su enfoque centrado en el diseño colaborativo y la creación de prototipos interactivos la convierte en la opción ideal para nuestro proyecto.

Además, Figma facilita el desarrollo colaborativo al permitir que varios miembros del equipo trabajen en un proyecto simultáneamente. Esta funcionalidad no solo mejora la eficiencia y la productividad, sino que también fomenta la comunicación y la colaboración entre los miembros del equipo. Otro aspecto destacado de Figma es su extensa biblioteca de recursos y modelos predefinidos que nuestro equipo puede utilizar como punto de partida para nuestros diseños. Estos modelos proporcionan una base sólida sobre la cual construir nuestras ideas y conceptos, lo que nos ayuda a ahorrar tiempo y esfuerzo en el proceso de diseño.

- Página oficial de Figma: https://figma.com/ 

---

#### Product Architecture Design:

Esta sección respecta al desarrollo y diseñado de las secciones basadas en la arquitectura del producto durante todo su ciclo de vida. Las herramientas utilizadas deben estar compuestas de varias aplicaciones con estilos varios que permitan la diagramación de esquemas complejos y completos sobre cada una de las capas de la arquitectura que mostrara nuestra solución, identificando todos sus componentes junto a los framework, IDEs y lenguajes de programación a utilizar.

**Diagramas C4:** Para abordar el diseño de todos los diagramas C4 relacionados con nuestro proyecto, nuestro grupo de trabajo ha llegado a una decisión unánime de utilizar la plataforma "Structurizr". Esta elección se basa en varios aspectos clave que consideramos fundamentales para garantizar un modelado claro y comprensible tanto para personas técnicas como no técnicas en el área. "Structurizr" se destaca por ofrecer modelos optimizados y especializados en el desarrollo de diagramas C4, lo que la convierte en una opción ideal para nuestro proyecto. Su enfoque centrado en la arquitectura y la visualización de sistemas complejos facilita la creación de diagramas claros y concisos que pueden ser entendidos por todos los miembros del equipo, independientemente de su nivel de experiencia técnica. Además, el equipo de trabajo tiene más experiencia en el uso de "Structurizr" en comparación con otros programas ya visualizados. Esto nos proporciona una ventaja adicional, ya que nos permite aprovechar al máximo todas las funcionalidades y características que ofrece la plataforma.

- Página oficial de Structurizr: https://structurizr.com/

**Diagrama UML:** Para abordar el diseño de todos los diagramas UML relacionados con nuestro proyecto y asegurar una representación precisa y detallada de la arquitectura del software, nuestro grupo de trabajo ha tomado una decisión unánime: utilizaremos "LucidChart". Esta plataforma se destaca por su especialización en el desarrollo de diagramas UML, lo que la convierte en la opción ideal para nuestras necesidades de modelado. "LucidChart" ofrece una amplia gama de herramientas y características diseñadas específicamente para la creación de diagramas UML, lo que nos permite representar de manera clara y concisa cada aspecto de la arquitectura de nuestro software. Su interfaz intuitiva y su conjunto completo de instrumentos hacen que el proceso de diagramación sea eficiente y productivo.

Además, "LucidChart" ofrece herramientas avanzadas para la organización y separación de partes en los diagramas UML, lo que nos permite estructurar y documentar de manera efectiva cada aspecto de nuestra arquitectura de software. Esto es fundamental para garantizar la comprensión y la comunicación claras entre los programadores expertos involucrados en el proyecto.

- Página oficial de LucidChart: https://lucidchart.com/

**Database Design:** Para abordar el diseño de la base de datos de nuestro proyecto y garantizar una estructura óptima que cumpla con las necesidades de nuestro equipo de gestión y desarrollo de bases de datos, hemos decidido utilizar "Vertabelo". Esta aplicación web se ha destacado por cumplir con todos los requisitos necesarios para el diseño de bases de datos de manera eficiente y rápida, lo que la convierte en la opción ideal para nuestro proyecto. "Vertabelo" ofrece una amplia gama de herramientas y funcionalidades diseñadas específicamente para el diseño de bases de datos. Su interfaz intuitiva y su conjunto completo de herramientas facilitan la creación de esquemas claros y concisos que pueden ser entendidos por todos los miembros del equipo, independientemente de su nivel de experiencia técnica.

Asimismo, "Vertabelo" permite la colaboración entre los miembros del equipo, lo que facilita la comunicación y la colaboración en el diseño y la implementación de la base de datos. Esta función es especialmente útil para un equipo distribuido como el nuestro, ya que nos permite trabajar juntos de manera efectiva.

- Página oficial de Vertabelo: https://vertabelo.com/

---

#### Software Development:

Esta sección respecta a las herramientas y aplicaciones dadas para la programación de las páginas web correspondientes a la Landing Page y a la Web Applications de nuestro proyecto durante todo su ciclo de vida. Los instrumentos utilizados deben estar compuestos de IDEs, lenguajes de programación, bibliotecas y frameworks, puesto que deben seguir todos los principios y metodologías predispuestas en todo el proyecto, además de adecuarse a todas las historias de usuario, esquemas y diagramas planteados para cumplir los objetivos de nuestra startup y seguir todas las funcionalidades que buscan nuestros segmentos objetivos.

**Landing Page:** En el proceso de desarrollo de la landing page, se emplearán diversas herramientas con el fin de garantizar su programación y esquematización de manera efectiva. En cuanto al lenguaje de programación, se optará por la combinación e implementación de HTML5, CSS3 y JavaScript, cada uno con su propia sección dedicada en el repositorio del grupo. Esta elección se fundamenta en la versatilidad y la amplia gama de funcionalidades que ofrecen estos lenguajes, siendo indispensables para la creación de páginas web aptas para un entorno de producción.

El diseño de la landing page estará orientado conforme al modelo del Material Design, un enfoque reconocido por su claridad y coherencia en la presentación de interfaces de usuario. Al seguir estas directrices de diseño, se busca garantizar una experiencia de usuario óptima y atractiva.

Para el desarrollo y la edición del código, se utilizará Visual Studio Code como IDE principal. Este entorno de desarrollo, aunque sencillo, ofrece una amplia gama de funcionalidades y extensiones que facilitan el proceso de desarrollo. Si bien es cierto que Visual Studio Code es ideal para proyectos estáticos de menor complejidad y alcance en comparación con otras IDEs más robustas, su simplicidad y facilidad de uso lo convierten en una opción adecuada para el desarrollo de la landing page.

- Página oficial de Visual Studio Code: https://code.visualstudio.com/

- Página de guía y seguimiento para HTML5: https://www.w3schools.com/html/ 

- Página de guía y seguimiento para CSS3: https://www.w3schools.com/css/default.asp

- Página de guía y seguimiento para JavaScript: https://developer.mozilla.org/es/docs/Web/JavaScript

- Página de guía y seguimiento para el modelo del Material Design: https://m3.material.io/

**Frontend Web Application:** En el proceso de desarrollo de la aplicación web frontend, se emplearán una variedad de herramientas para garantizar su programación eficiente y una esquematización adecuada, en armonía con el diseño conjunto de múltiples componentes. Para ello, se optará por el Angular Framework, el cual ofrece una sólida base para el desarrollo de software para frontend y una estructura de programación bastante eficiente. Este Framework, combinado con la versatilidad y potencia de HTML5, CSS3 y JavaScript, conformará el núcleo de la implementación técnica. Además, se incorporará TypeScript para el desarrollo de los aspectos estáticos de los templates, contribuyendo así a la robustez y mantenibilidad del código.

En cuanto al entorno de desarrollo integrado (IDE), se utilizará la plataforma medida y proporcionada por Angular. Estas herramientas se distinguen por su alta resistencia a cambios, depuraciones y actualizaciones de código inmediatas y son especialmente adecuadas para proyectos frontend de gran envergadura y alcance. TypeScript será el principal lenguaje de programación empleado dentro de esta IDE, permitiendo un desarrollo ágil y eficiente.

El enfoque de diseño estará basado en el modelo del Material Design, que proporciona pautas claras y consistentes para la creación de interfaces de usuario atractivas y funcionales. Para materializar este diseño, se recurrirá a la biblioteca de materiales y componentes de UI dada por Angular Material. Esta elección se fundamenta en su compatibilidad con el Framework de Angular, lo que garantiza una integración fluida y eficaz, así como una rápida implementación de la aplicación web en su totalidad.

- Página oficial de Angular: https://angular.io/

- Página de especificación de Angular para la biblioteca de Angular Material: https://material.angular.io/

- Página de guía y seguimiento para HTML5: https://www.w3schools.com/html/ 

- Página de guía y seguimiento para CSS3: https://www.w3schools.com/css/default.asp

- Página de guía y seguimiento para JavaScript: https://developer.mozilla.org/es/docs/Web/JavaScript

- Página de guía y seguimiento para TypeScript: https://www.typescriptlang.org/

- Página de guía y seguimiento para el modelo del Material Design: https://m3.material.io/

**Web Services:** En el proceso de desarrollo de los Web Services, es fundamental adoptar modelos y metodologías que faciliten la programación eficiente y la implementación de un Backend robusto y de alto rendimiento. Para ello, se prevé utilizar frameworks que cuenten con bibliotecas preimplementadas y que permitan una integración fluida de los servicios web.

El estilo de aplicación seleccionado será el RESTful API Architectural Style, reconocido por su capacidad para ofrecer una comunicación rápida y directa entre clientes y servidor, así como por su adopción generalizada de buenas prácticas de diseño y seguridad. Este enfoque garantiza un Backend sólido y escalable, además de facilitar la adopción de prácticas de desarrollo consistentes y seguras.

En cuanto al framework de desarrollo, se optará por Spring Boot, un modelo cómodo y potente que ofrece un conjunto completo de herramientas para la creación de servicios web en grupo con Java. Al combinar Spring Boot con el lenguaje de programación Java, se obtiene un entorno de desarrollo robusto y resistente, capaz de manejar las demandas de un backend de alto rendimiento de manera eficiente. En cuanto al entorno de desarrollo integrado (IDE), se utilizará la plataforma proporcionada por el grupo de aplicaciones JetBrains Toolbox. Estas herramientas se distinguen por su robustez y son especialmente adecuadas para proyectos backend de gran resistencia y conexión avanzada.

Para la documentación de los servicios web, se utilizará el modelo Swagger proporcionado por OpenAPI Specification. Este modelo se ha establecido como un estándar en la industria y ofrece una forma estructurada y coherente de documentar APIs, lo que facilita su comprensión y utilización tanto para desarrolladores internos como externos. Además, Swagger permite un registro rápido de los cambios en la API durante el desarrollo, lo que resulta invaluable para mantener la documentación actualizada y precisa en todo momento.

- Página oficial de Jetbrains Toolbox: https://www.jetbrains.com/toolbox-app/

- Página oficial de Spring Boot: https://spring.io/projects/spring-boot

- Página oficial de Swagger: https://swagger.io/ 

- Página de guía y seguimiento para Java: https://www.java.com/es/

- Página de guía y seguimiento para el modelo REST: https://es.apis.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

---

#### Software Testing:

Esta sección corresponde a las herramientas y aplicaciones dadas para la programación de modelos de testeo para todo el código que vamos a implementar, de forma que pueda garantizar el correcto funcionamiento de todas las clases, componentes, métodos de comunicación, etc. Los instrumentos utilizados deben estar basados en un programa sencillo o en una metodologia que permita la comprobación correcta de todas las funcionalidades de un código en varios escenarios distintos.

Como usamos el editor de codigo Visual Studio Code podremos hacer uso de la extension Live Server. Con esta extensión, tenemos la capacidad de configurar un servidor local, lo que nos facilita la visualización inmediata de las modificaciones que realizamos en un navegador web como Microsoft Edge o Chrome. De esta forma no perdemos tiempo al realizar compilaciones o depuraciones inmediatas. Asimismo, con respecto a las pruebas de aceptación, utilizaremos las herramientas brindadas por la extensión de Cucumber ofrecida también por Visual Studio Code, siguiendo el modelo del esquema Gherkin para garantizar una estructura funcional y ya ordenada.

- Página de marketplace de Live Server de Visual Studio Code: https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer

- Página de marketplace de Cucumber de Visual Studio Code: https://marketplace.visualstudio.com/items?itemName=CucumberOpen.cucumber-official

- Guía de Cucumber para el modelo Gherkin: https://cucumber.io/docs/gherkin/

---

#### Software Deployment:

Esta sección corresponde a las herramientas y aplicaciones dadas para el despliegue e implementación adecuada de todas las páginas web que se programaran a lo largo de todo el ciclo de vida de nuestro proyecto. Los instrumentos utilizados deben ser sencillos de comprender y deben mostrar confianza y garantía al momento de desplegar todas las páginas para que así ninguna de estas se caiga por el mal rendimiento, o terminen saliendo con formatos distintos a los propuestos.

Para todo el despliegue necesario de la Landing Page, nuestro grupo va a utilizar el servicio dado de Github Pages, el cual otorga rendimiento rápido y garantía asegurada ante el uso de los repositorios que se encuentran en la misma plataforma. Asimismo, al ser una página estatica, la Landing Page no requiere muchos cambios y tampoco actualizaciones consecutivas y continuas. 

- Página oficial de Github Pages: https://pages.github.com/

---

#### Software Document:

Esta sección corresponde a las herramientas y aplicaciones dadas para la documentación precisa de todo el reporte de programación junto a la propia documentación del software durante todo el ciclo de vida de nuestro proyecto. Las herramientas utilizadas para este proceso deben ser sencillas de comprender y manipular para todos los miembros del equipo, además de que deben ser adecuadas para el uso de textos largos con grandes cantidades de informcación, junto a soportar imagenes y seguir buenos modelos de división en secciones.

Para toda la documentación se utilizara un repositorio propio dentro de Github, el cual estara separado en varias ramas y se encontrara dentro de la propia organización del equipo de trabajo. Durante el proceso de escritura se debe usar el lenguaje de marcado de Markdown, de forma que se pueda garantizar la lectura en medios web a través de varios dispositivos y se pueda garantizar métodos de compresión y envio de data cifrada. Asimismo, con el fin de utilizar herramientas más especializadas, se usara el lenguaje HTML en ciertas secciones del desarrollo que no puedan ser escritas de forma cómoda y aceptable mediante Markdown, como, por ejemplo, las tablas de gran tamaño y división. 

- Página oficial de Github: https://github.com/ 

- Página de guía de uso de Markdown: https://www.markdownguide.org/ 

- Página de guía y seguimiento para HTML5: https://www.w3schools.com/html/ 

---

### 5.1.2 Source Code Management.

En esta sección se establecerá la estrategia principal para utilizar GitHub como plataforma y sistema de control de versiones entre todas las colaboraciones dadas por el equipo de trabajo durante todo el ciclo de vida del proyecto. Es necesario utilizar todas las herramientas implementadas y estipuladas durante el uso del proyecto y seguir el historial de versiones para identificar posibles cambios nuevos o posibles errores que deben ser eliminados.

La siguiente lista presenta todos los enlaces respectivos a la organización de Github de SportEase y a todos los repositorios dentro de esta organización presentada:

**Repositorios en GitHub**

- Organización: https://github.com/upc-pre-202401-si729-sv54-sportease
- Landing Page: https://github.com/upc-pre-202401-si729-sv54-sportease/upc-pre-202401-si729-sv54-sportease-landing-page
- Report : https://github.com/upc-pre-202401-si729-sv54-sportease/upc-pre-202401-si729-sv54-sportease-report

**GitFlow Workflow**

En nuestro caso se implementará el modelo GitFlow como WorkFlow de control de versiones, el cual incluye ramas principales como main y develop, las cuales funcionan como bases para el desarrollo e implementación final de todo un proyecto; así como ramas de características, lanzamiento y corrección, las cuales funcionan como ramas provisionales, las cuales tienen caracteristicas extras que esperan ser integradas en el producto final mediante un pull request dado por un miembro o por todo el equipo de trabajo. Esta estrategia proporciona una organización efectiva para el seguimiento de cambios, colaboración en el equipo y gestión de versiones del proyecto.

En esta sección explicaremos de qué forma se implementará GitFlow. Para este modelo presentado, cada Feature requiere su propio branch idealmente para luego ser integrado mediante un pull request ya establecido. Ante esta estrategia ya utilizada por nuestro equipo de trabajo, se explicaran y especificaran las convenciones que se deben aplicar para todos los titulos que llevaran las ramas creadas por nuestro equipo de trabajo:

1. **Branches Principales:**

- `main`: Esta rama es la que contendrá la versión final y estable del proyecto, completamente lista para su despliegue. Esta es la última rama en la que se deben hacer merges y todo cambio nuevo debe ser revisado obligatoriamente por todo el proyecto en conjunto o, por lo menos, todos los que puedan revisarlo en conjunto.
  
- `develop`: Esta rama es en la que se agrupan todos los elementos en desarrollo que ya han sido aceptados por al menos un integrante del equipo que no sea quien haya realizado el feature. Esta rama funciona como una última comprobación del funcionamiento de todos los nuevos features y caracteristicas agregadas. Una vez que el desarrollo está completo y se considera listo para avanzar al siguiente paso, se fusionará con la rama principal de lanzamiento (main).

2. **Branches de Funcionalidades (Feature Branches):**

- `feature`: Para cada nueva funcionalidad, se creará una rama de funcionalidad con el prefijo "feature/", seguido del nombre descriptivo de la función o característica. En nuestro caso, creamos 5 branches de características correspondientes a los 5 capítulos de nuestro informe, donde se realizan los commits respectivos antes de fusionarlos con la rama develop cuando estén listos. Estas ramas generales son respectivas a cada capitulo del reporte del proyecto y es donde los miembros del grupo de trabajo deben realizar sus pull request en primer lugar, con el fin de conseguir orden y seguridad en todo momento, junto a una buena división y organización:

| Nombre | Descripción |
|--------|-------------|
| feature/chapter-01/introduction | En esta rama se realizan todos los cambios respectivos a las secciones del Capitulo 1 del reporte del proyecto. En este feature se agregaron todas las partes referentes a la introducción del reporte, de nuestro startup y de nuestro producto. | 
| feature/chapter-02/requirements-elicitation-analysis | En esta rama se realizan todos los cambios respectivos a las secciones del Capitulo 2 del reporte del proyecto. En este feature se agregaron todas las partes referentes a la obtención y análisis de los requisitos para el proyecto y a nuestra posición en el mercado actual junto a nuestro segmento de mercado. |
| feature/chapter-03/requirements-specification | En esta rama se realizan todos los cambios respectivos a las secciones del Capitulo 3 del reporte del proyecto. En este feature se agregaron todas las partes referentes a la especificación de todos los requisitos y requerimientos de funcionalidades. |
| feature/chapter-04/product-design | En esta rama se realizan todos los cambios respectivos a las secciones del Capitulo 4 del reporte del proyecto. En este feature se agregaron todas las partes referentes al modelado del diseño UI/UX que tendra nuestra landing page y aplicación web. |
| feature/chapter-05/product-implementation-validation-deployment | En esta rama se realizan todos los cambios respectivos a las secciones del Capitulo 5 del reporte del proyecto. En este feature se agregaron todas las partes referentes a la implementación del producto, a su validación con todos los miembros del equipo y a su despliegue en un ambiente de producción. |

* **Features individuales:** Estas ramas individuales son respectivas a todos los cambios que hará cada programador de nuestro equipo en solitario, para luego integrarlos a los features principales de los capitulos mediante un pull request que debe ser aceptado por el líder del equipo de trabajo. Estas branchs luego se eliminaran para evitar la sobrecarga del espacio.

--- 

Para mantener una convención clara y coherente en el nombramiento de todas las ramas, así como en los modelos de pull request y commits realizados por todos los miembros de nuestro equipo de trabajo, hemos establecido el siguiente formato estándar:

| feat(branch): verb + simple description in English |
|----------------------------------------------------|

En este formato, la sección branch debe especificar la rama en la que se ha realizado el cambio propuesto en el nuevo feature. En el caso de cambios realizados en una rama de un capítulo específico, simplemente se debe utilizar "chapter-xx" para evitar alargar la convención del commit o pull request.

Respecto a la descripción, esta debe estar redactada íntegramente en inglés y debe comenzar con un verbo que indique claramente el cambio que se va a realizar. A continuación, se proporciona una lista de verbos que pueden ser útiles en este contexto:

| Verbo | Traducción | Uso en el proyecto de programación |
|-------|------------|------------------------------------|
| Add | Añadir | Usado para agregar alguna nueva sección, imagen, texto, etc., a una parte del proyecto. Lo ideal es solo usarlos en las features de los capitulos en forma de commits o en features individuales que esperan un pull request. |
| Create | Crear | Usado exclusivamente para la creación del encabezado de secciones sin más contenido o para la creación de documentos y/o ramas dentro del proyecto que se usen como base general. |
| Update | Actualizar | Usado para actualizar alguna sección del proyecto. Lo ideal es que al usarlo solo se hagan agregaciones pequeñas en una sección del proyecto o cambios que no modifiquen la base original de la sección. |
| Modify | Modificar | Usado para modificar alguna sección del proyecto. Al modificar alguna sección, esta es cambiada casi completamente y se realiza con nuevas bases. El modificar algo se diferencia de actualizar porque el contenido modificado es cambiado desde la raíz. |
| Correct | Corregir | Usado para corregir algún aspecto de una sección del reporte del proyecto. Esta corrección debe ser menor en comparación a una actualización y se debe usar mayoritariamente para la correción de ortografía y/o grámatica.
| Fix | Arreglar | Usado para arreglar alguna sección que sea correspondiente a código de programación para alguna parte del Web Application o de la Landing Page. También se puede usar en el reporte del proyecto para arreglar artefactos que no funcionan, como enlaces.
| Delete | Borrar | Usado para borrar alguna sección, imagen, etc., de una parte del proyecto. Solo debe usarse para eliminar una sección incorrecta que ya haya sido aceptada por los miembros del grupo de trabajo. |
| Drop | Tirar | Usado exclusivamente para tirar abajo alguna rama, carpeta, etc., de todo el repositorio. Solo utilizar cuando el equipo del proyecto acepto tal dropeo. |

Esta norma se utilizara para mantener y seguir el modelo de los Conventional Commits, los cuales son una convención y especificación ligera para la estructuración y nombramiento de los commits realizados por un equipo. Proporciona un conjunto sencillo de reglas para crear un historial de confirmaciones explícito; lo que facilita la escritura de herramientas automatizadas encima. Esta convención es muy útil al querer describir las características, correcciones y cambios importantes realizados en los mensajes de confirmación. (Github & Netlify, 2024). 

Finalmente, también se adoptará el uso de los Conventional Commits para los mensajes de texto y descripción en cada commit realizada en el proyecto. La estructura de estos mensajes será:

| type: description |
|-------------------|

**Versionado Semántico**

Con respecto a las versiones de lanzamiento de las secciones de programación del proyecto, se debe seguir el versionado semántico 2.0.0., el cual se basa en la siguiente estructura. 

| Major.Minor.Patch. |
|--------------------|

donde, 

- El último dígito (Parche) se refiere principalmente a corrección de errores compatibles con versiones anteriores.
- El segundo dígito (Menor) aumenta cuando se añaden características compatibles con la versión anterior.
- El primer dígito (Mayor) se incrementa para cambios significativos que podrían no ser compatibles con la versión anterior.

---

### 5.1.3 Source Code Style Guide & Conventions.

En esta sección, nuestro equipo de trabajo explicara e indicar las referencias que adoptaremos para nombrar y programar en los lenguajes de programación que se utilizar para el diseñado de nuestra solución de software mediante la Landing Page y el Web Applications. Ante esto, especificaremos todas las convenciones dadas para los siguientes lenguajes de programación o lenguajes de etiquetas junto a sus guías de seguimiento:

- Guía de Estilos y Convenciones de Codigo para HTML: https://www.w3schools.com/html/html5_syntax.asp 
- Guía de Estilos de Google para HTML Y CSS: https://google.github.io/styleguide/htmlcssguide.html 
- Convenciones de Gherkin para especificaciones legibles: https://specflow.org/gherkin/gherkin-conventions-for-readable-specifications/ 
- Guía de Google para el Estilo de JavaScript: https://google.github.io/styleguide/jsguide.html
- Guía de Pautas de Javascript de MDN (Mozilla): https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/JavaScript}
- Guía de Estilos de Javascript del consorcio W3: https://www.w3schools.com/js/js_conventions.asp
- Guía de convenciones de Código para Angular: https://angular.io/guide/styleguide
- Guía de los Estilos de Spring Boot: https://docs.spring.io/spring-boot/docs/current/reference/html/features.html

Se tiene la intención de seguir todas estas directrices y normativas de codificación establecidas, además de modelar los diseños de las nomenclaturas y seguir el lenguaje inglés ante la recomendación mayoritaria frente a la codificación de nuestras páginas web. Estableceremos las convenciones y prácticas que seguiremos para nombrar elementos y programar en los lenguajes utilizados en la solución, que incluyen HTML, CSS, JavaScript, TypeScript, Angular, Java y Gherkin para los archivos `.feature`. Todas las convenciones seguirán la nomenclatura en inglés y adoptarán convenciones estándar de codificación.

1. **HTML**:

- Para el guardado y actualización de archivos HTML se deben usar nombres descriptivos y sencillos que resuman adecuadamente todas las estructuras que se realizaron durante el proceso de programación.
- Seguir una convención de nomenclatura consistente para los archivos y carpetas utilizadas durante todo el ciclo de vida del proyecto, como camelCase o algún otro similar que cumpla con las mismas especificaciones.
- Utilizar las etiquetas HTML de manera semántica para describir adecuadamente la estructura y el contenido de tu página web. Por ejemplo, utilizar header, nav, main, section, article, footer, etc., en lugar de divs genéricos.
- Mantener una estructura de código clara y legible mediante la indentación adecuada. Promover la coherencia en el diseño y la presentación en todas las partes del proyecto, garantizando una experiencia de usuario uniforme.
- Utilizar etiquetas semánticas y atributos como "alt" en las imágenes para mejorar la accesibilidad y la indexación por parte de los motores de búsqueda/browsers.
- Diseñar el HTML para que sea receptivo y se vea bien en una variedad de dispositivos y tamaños de pantalla, utilizando CSS adaptable y consultas de medios adecuados.
- Utilizar modelos de accesibilidad para aumentar el alcance del público que interactua con las páginas web. Centrarse en seguir con el diseño para permitir que puedan acceder personas con discapacidades o con otras lenguas y/o creencias y culturas.
- Se seguirán las convenciones recomendadas por Google para HTML, que incluyen el uso de identaciones de 2 espacios, el uso de comillas dobles para atributos y el uso de comentarios descriptivos.

2. **CSS**:

- Se seguirán las convenciones recomendadas por Google para CSS, que incluyen el uso de identaciones de 2 espacios, el uso de comillas dobles para atributos y el uso de comentarios descriptivos.
- Utilizar nombres de clases descriptivos y coherentes para facilitar la comprensión del código y su mantenimiento a largo plazo. Se deben seguir metodologías como BEM (Block Element Modifier) y SMACSS (Scalable and Modular Architecture for CSS).
- Utilizar nombres descriptivos para las clases CSS que reflejen su propósito o función en lugar de nombres genéricos o abreviaturas difíciles de entender.
- Preferir nombres que reflejen la función o el propósito del elemento en lugar de su apariencia.
- Diseñar CSS modular para que se pueda reutilizar estilos en diferentes partes de la landing page y la propia aplicación web, lo que facilita la mantenibilidad y la escalabilidad.
- Utilizar prefijos de proveedores CSS (como -webkit-, -moz-, -ms-, -o-) cuando sea necesario para garantizar la compatibilidad con diferentes navegadores.
- Evitar aplicar estilos directamente en las etiquetas HTML (style attribute) y en su lugar utiliza clases CSS para mantener la separación entre HTML y CSS.
- Evitar estilos en línea en HTML, ya que hacen que sea más difícil de mantener y sobrescribir. Es preferible definir estilos en un archivo CSS separado.
- Realizar pruebas en diferentes navegadores y dispositivos para asegurarte de que tus estilos se vean y funcionen correctamente en todas las situaciones.

3. **JavaScript**:

- Utilizar nombres descriptivos que reflejen el propósito y la función de las variables y funciones para mejorar la comprensión del código a gran escala y durante todo su ciclo de vida.
- Adoptar el estilo de nomenclatura CamelCase para nombrar variables y funciones, comenzando con minúscula para las variables y con mayúscula para las funciones. Asimsmo, utilizar espacios o tabulaciones de manera consistente y asegurarse de mantener una línea de código por línea para mejorar la legibilidad.
- Utilizar "const" para declarar variables que no cambiarán de valor y "let" para aquellas que sí lo harán, en lugar de "var", para evitar problemas de alcance y mantener la inmutabilidad cuando sea posible.
- Documentar el código utilizando comentarios para explicar el propósito de las funciones, algoritmos complejos, decisiones de diseño y cualquier otra información relevante. Sin embargo, al enviar a producción, todos esos comentarios deben eliminarse. En caso el comentario sea demasiado importante y aún se debe mantener en el ambiente de producción, lo mejor es dejarlo con la mayor descripción posible sobre su necesidad, usando un formato agradable y formal.
- Limitar el uso de variables globales ya que pueden causar conflictos y dificultar el mantenimiento del código. Preferir encapsular variables y funciones dentro de módulos o funciones autoejecutables para evitar contaminar el espacio global.
- Implementar un manejo adecuado de errores utilizando bloques try-catch para capturar excepciones y manejar errores de manera apropiada, proporcionando mensajes claros y útiles para facilitar la depuración.
- Asegurarse de que las comparaciones y operaciones sean explícitas y predecibles para evitar errores de tipo. Utiliza operadores estrictos (=== y !==) en lugar de los operadores de igualdad débil (== y !=) siempre que sea posible.
- Utilizar la delegación de eventos para manejar eventos en elementos dinámicos y reducir la cantidad de manipuladores de eventos necesarios en el DOM.
- Aprovechar las funciones de orden superior como "map", "filter", "reduce" y "forEach" para simplificar el código y mejorar su legibilidad.

4. **Typescript**:

- Aprovechar al máximo el sistema de tipos de TypeScript proporcionando tipos explícitos para variables, parámetros de función y valores de retorno. Esto mejora la legibilidad del código y ayuda a detectar errores en etapas tempranas de desarrollo.
- Utilizar interfaces y tipos para definir la forma de los objetos y estructuras de datos en el código. Esto facilita la comprensión de cómo deben estructurarse los datos y permite la reutilización de tipos en todo el proyecto.
- Evitar el uso excesivo del tipo "any", ya que elimina los beneficios del sistema de tipos de TypeScript. En su lugar, intentar ser lo más específico posible con los tipos de datos que se utilicen.
- Utilizar uniones (|) y tipos de intersección (&) para modelar tipos complejos que puedan tener múltiples formas o combinaciones de tipos.
- Aprovechar las generics de TypeScript para crear funciones y clases que sean flexibles y reutilizables con diferentes tipos de datos. Asimismo, aprovechar la capacidad de TypeScript para inferir tipos cuando sea posible, especialmente en situaciones donde la tipificación explícita podría ser redundante.
- Adoptar el estilo de nomenclatura CamelCase para nombrar variables y funciones, comenzando con minúscula para las variables y con mayúscula para las funciones. Asimsmo, utilizar espacios o tabulaciones de manera consistente y asegurarse de mantener una línea de código por línea para mejorar la legibilidad.
- Habilitar la configuración "strict" en el archivo de configuración tsconfig.json para aprovechar al máximo las características de seguridad y verificación de TypeScript.
- Documentar el código TypeScript utilizando comentarios JSDoc para describir el propósito, los parámetros y el valor de retorno de las funciones, clases y métodos. Sin embargo, al enviar a producción, todos esos comentarios deben eliminarse. En caso el comentario sea demasiado importante y aún se debe mantener en el ambiente de producción, lo mejor es dejarlo con la mayor descripción posible sobre su necesidad, usando un formato agradable y formal.

5. **Angular**:

- Organizar el proyecto de Angular siguiendo una estructura clara y coherente, como la proporcionada por la CLI de Angular, que separa los archivos por funcionalidad y tipo (componentes, servicios, módulos, etc.).
- Diseñar componentes Angular que sean reutilizables y modulares, lo que facilita su uso en diferentes partes de la aplicación y fomenta la consistencia en el diseño y la funcionalidad.
- Utilizar servicios para encapsular la lógica de negocio y compartir datos y funcionalidades entre componentes de manera eficiente, cohesiva y coherente. 
- Utilizar módulos Angular para organizar y agrupar componentes, servicios y otros elementos relacionados de tu aplicación, lo que facilita la escalabilidad y el mantenimiento.
- Utilizar directivas y pipes de Angular para manipular el DOM y transformar datos en las plantillas HTML de manera declarativa y eficiente.
- Utilizar Observables y el Reactive Extensions for JavaScript (RxJS) para manejar la asincronía y la programación reactiva en la aplicación Angular, lo que simplifica la gestión de eventos y el flujo de datos.
- Utilizar el enrutamiento Angular para gestionar las rutas y la navegación en la aplicación, lo que permite cargar componentes de forma dinámica según la URL y proporcionar una experiencia de navegación fluida.
- Utilizar formularios reactivos de Angular para crear formularios dinámicos y robustos que puedan adaptarse fácilmente a los cambios en los datos y proporcionar una experiencia de usuario más interactiva.
- Optimizar el rendimiento de la aplicación Angular utilizando técnicas como la lazy loading de módulos, la minimización de solicitudes HTTP, el preloading de módulos, el uso eficiente de Directivas estructurales y el Change Detection Strategy OnPush.
- Se adoptarán las convenciones de codificación recomendadas por la comunidad de Angular, que incluyen el uso de camelCase para los nombres de archivos y carpetas, así como para los nombres de componentes, directivas y servicios.

6. **Java**:

- Utilizar nombres descriptivos y significativos para clases, variables, métodos y paquetes. Seguir las convenciones de nomenclatura de Java para mantener la consistencia en todo el proyecto.
- Seguir la convención de nomenclatura de Java, que generalmente utiliza CamelCase para nombres de variables y métodos, y PascalCase para nombres de clases e interfaces.
- Organizar tus clases en paquetes lógicos y bien estructurados que reflejen la arquitectura y la funcionalidad de tu aplicación.
- Diseñar el código de Java para que sea modular y cohesivo, dividiendo la funcionalidad en clases y métodos pequeños y bien definidos.
- Utilizar la inyección de dependencias para facilitar la creación y gestión de componentes y servicios en tu aplicación Java. Esto mejora la modularidad, la reutilización y la testabilidad del código. 
- Implementar un manejo adecuado de excepciones utilizando bloques try-catch-finally para capturar y manejar excepciones de manera adecuada, proporcionando mensajes significativos y tomando acciones apropiadas en caso de error.
- Documentar el código utilizando comentarios Javadoc para proporcionar información útil sobre la funcionalidad, los parámetros y el valor de retorno de los métodos y clases. Esto facilita la comprensión del código y la generación de documentación automática. Sin embargo, al enviar a producción, todos esos comentarios deben eliminarse. En caso el comentario sea demasiado importante y aún se debe mantener en el ambiente de producción, lo mejor es dejarlo con la mayor descripción posible sobre su necesidad, usando un formato agradable y formal.
- Utilizar interfaces para definir contratos y abstracciones en tu código, lo que facilita la modularidad, la reutilización y la interoperabilidad.
- Optimizar el rendimiento de tu código Java utilizando técnicas como la optimización de bucles, la minimización del uso de la memoria, la utilización de estructuras de datos eficientes y el caching cuando sea necesario.

7. **Gherkin**:

- Utilizar las palabras clave de Gherkin (Given, When, Then, And, But) de manera apropiada para estructurar tus escenarios de acuerdo con el flujo de acción deseado.
- Escribir escenarios en un lenguaje claro y comprensible para todas las partes interesadas, incluidos los no técnicos. Utilizar un vocabulario simple y evitar la jerga técnica cuando sea posible.
- Asegurarse de que cada escenario se centre en un único aspecto o funcionalidad de la aplicación. Evitar la superposición de funcionalidades en un solo escenario para mantenerlos simples y fáciles de entender.
- Mantener los escenarios lo más concisos y directos posible. Evitar la repetición innecesaria y eliminar cualquier detalle que no sea relevante para el objetivo del escenario.
- Escribir los escenarios en primera persona, desde la perspectiva del usuario o actor que realiza la acción. Esto ayuda a mantener un enfoque centrado en el usuario y facilita la comprensión del comportamiento esperado.
- Evitar incluir detalles de implementación en los escenarios. En su lugar, uno debe concentrarse en describir el comportamiento esperado de la aplicación sin preocuparse por cómo se logra ese comportamiento.
- Identificar patrones comunes en los escenarios y buscar oportunidades para reutilizar pasos utilizando escenarios de fondo (Background) o pasos compartidos (Step Definitions).

Además de estas referencias, se promoverá el uso de buenas prácticas y metodologías estándar en el desarrollo de software, como la modularidad, la reutilización de código, la legibilidad del código, la optimización del rendimiento y la seguridad. Con estas guías de estilo y convenciones de codificación, buscamos asegurar la coherencia, la calidad y la mantenibilidad del código a lo largo de todo el proyecto.

### 5.1.4 Software Deployment Configuration.

En esta sección, describiremos la configuración necesaria para desplegar satisfactoriamente cada uno de los productos digitales de nuestra solución, incluyendo Landing Page, los Web Services y las Frontend Web Applications.

1. Landing Page: Empezaremos por crear un repositorio en GitHub para almacenar los archivos HTML, CSS y JavaScript. Luego cada integrante del equipo trabajará en su propia rama "feature" para desarrollar nuestro landing page. Una vez completada una característica, se procederá a hacer el merge con la rama "develop" para que la landing page se encuentre actualizada. estableceremos la configuración en GitHub Pages para publicar la página de destino utilizando la rama "develop". A continuación, detallamos los pasos para llevar a cabo este despliegue en GitHub Pages:

- Comenzaremos creando un repositorio público en GitHub y poniendole un nombre.
- Configurar las ramas necesarias conforme al flujo de trabajo Gitflow estándar, que comprende main, release, develop, features y hotfix.
- Dirigirse a la sección de ajustes y elegir la pestaña Pages.
- Nos dirigimos al apartado de configuración para GitHub Pages.
- En el apartado de branch, seleccionamos el branch "develop" donde se realizará el despliegue del landing page, dejando las demás configuraciones con sus valores predeterminados.
- Al seleccionar la rama correspondiente, se generará un enlace que permitirá acceder al landing page. Cada modificación efectuada en el "develop" se actualiza automáticamente.
- Cada miembro del equipo trabajará en sus propias ramas.
- Se realizarán merges entre la develop y los feature para integrar los avances.
- Se observarán los cambios reflejados en el enlace provisto por GitHub Pages.
- Finalmente, el landing estará desplegada, lista para ser visualizada y utilizada.

2. Web Services (API):
- Preparar el código fuente del servicio web, asegurando que esté correctamente estructurado y documentado.
- Configurar un entorno de desarrolo o pruebas para realizar pruebas exhaustivas del servicio antes del desplieguee.
- Desplegar el código en un servidor adecuado para el entorno de producción.
- Configurar la seguridad y la autenticación según los requisitos del sistema.
- Documentar la API utilizando OpenAPI Specification para facilitar su integración y uso por parte de otros sistemas.

3. Frontend Web Applications:
- Clonaremos el repositorio desde GitHub.
- Compilaremos y empaquetaremos las aplicaciones frontend. En nuestro caso, utilizando Angular, ejecutaremos los comandos de construcción (npm run build) para generar los archivos estáticos.
- Una vez empaquetadas, las Aplicaciones Frontend Angular pueden ser servidas utilizando un servidor de aplicaciones compatible con archivos estáticos, como Nginx o GitHub Pages para proyectos estáticos más simples.
- Si es necesario, configuraremos las rutas en el servidor de aplicaciones para que coincidan con las rutas esperadas por las aplicaciones frontend.

## 5.2 Landing Page, Services & Applications Implementation.

En esta sección, describiremos el proceso de implementación, pruebas, documentación y despliegue de la Landing Page, los Web Services y las Frontend Web Applications. Abordaremos cada componente de manera individual a lo largo de los diferentes sprints, comenzando en este Sprint 1 con la implementación específica de la Landing Page. Una vez establecido nuestro Product Backlog, cada sprint se dividirá en secciones internas para abordar cada aspecto de la implementación y la colaboración del equipo.

### 5.2.1 Sprint 1

En esta sección, documentaremos y explicaremos el progreso tanto en el desarrollo del producto como en la colaboración del equipo durante el Sprint 1. Seguimos un proceso definido que abarca desde la planificación hasta la revisión y documentación del trabajo realizado. A lo largo de las siguientes secciones, detallaremos cómo se llevó a cabo la planificación del sprint, qué tareas se incluyeron en el Sprint Backlog, las pruebas y evidencia de desarrollo para la revisión del sprint, así como la documentación de los servicios y las percepciones clave sobre la colaboración del equipo durante este periodo.

### 5.2.1.1 Sprint Planning 1

En esta sección, se detallan los aspectos principales del Sprint Planning Meeting para el Sprint n. Este encuentro es crucial para establecer los objetivos del sprint, determinar las user stories que se abordarán y asignar tareas al equipo. A continuación, se presenta un resumen del Sprint Planning Meeting para este período.

<table>
        <tr>
            <td colspan="1">Sprint #</td>
            <td colspan="1">Sprint 1</td>
        </tr>
        <tr>
            <td colspan="2">Sprint Planning Background</td>
        </tr>
        <tr>
            <td>Date</td>
            <td>2024-04-01</td>
        </tr>
          <tr>
            <td>Time</td>
            <td>04:06 PM</td>
        </tr>
            <tr>
            <td>Location</td>
            <td>Google Meet</td>
        </tr>
            <tr>
            <td>Prepared by</td>
            <td>Piero Abel Tarazona Medina</td>
        </tr>
            <tr>
            <td>Attendees (to planning meeting)</td>
            <td>Moises Rodolfo Donayre Peña, Mauricio Sebastián Chacon Martinez, Flavio Eduardo Trigueros Chumacero, Piero Abel Tarazona Medina</td>
        </tr>
            <tr>
            <td>Sprint 1 – 1 Review Summary</td>
            <td>l Sprint 1 fue un éxito en términos de avance del producto de software y colaboración efectiva del equipo. Los logros alcanzados y la retroalimentación recopilada durante esta revisión proporcionan una base sólida para el siguiente sprint y refuerzan el compromiso del equipo con la calidad y la entrega oportuna del producto.</td>
        </tr>
            <tr>
            <td>Sprint 1 – 1 Retrospective Summary</td>
            <td>Para la retrospectiva del Sprint 1 nos sirvio para reflexionar sobre el desempeño del equipo y identificar áreas de mejora. Esto nos servira como base para impulsar la mejora continua y optimizar el trabajo del equipo en los próximos sprints.</td>
        </tr>
            <tr>
            <td colspan="2">Sprint Goal & User Stories</td>
        </tr>
              <tr>
            <td>Sprint 1 Goal</td>
            <td>Alcanzar una métrica de cumplimiento del 100%, lo que indicará que se ha logrado los objetivos del sprint 1.</td>
        </tr>
              <tr>
            <td>Sprint 1 Velocity</td>
            <td>Con el equipo para este sprint 1 decidimos aceptar 5 Story Points </td>
        </tr>
              <tr>
            <td>Sum of Story Points</td>
            <td>La suma de los Story Points para los User Stories que se están incluyendo en este Sprint 1 es 5</td>
        </tr>
    </table>

### 5.2.1.2 Sprint Backlog 1

El Sprint 1 está centrado en la implementación de las funcionalidades clave de la landing page del sitio web, priorizando las historias de usuario identificadas. Nuestro objetivo principal es proporcionar a los visitantes una experiencia inicial sólida al presentar de manera clara y concisa las características y beneficios del sitio, junto con una navegación intuitiva y acceso rápido a la información relevante. Al completar las tareas asociadas a las historias de usuario definidas, sentaremos las bases para futuras iteraciones, asegurando que la página de inicio cumpla con las expectativas de los usuarios y contribuya al éxito del proyecto.

<table>
    <tr>
        <td colspan="2">Sprint #</td>
        <td colspan="6">Sprint 1</td>
    </tr>
    <tr>
        <td colspan="2">User Story</td>
        <td colspan="6">Work-Item / Task</td>
    </tr>
    <tr>
        <td>Id</td>
        <td>Title</td>
        <td>Id</td>
        <td>Title</td>
        <td>Descripcion</td>
        <td>Estimation (Hours)</td>
        <td>Assigned To</td>
        <td>Status (To-do / In / Process / ToReview / Done)</td>
    </tr>
    <tr>
        <td>US01</td>
        <td>Presentación de la página de inicio</td>
        <td>T01</td>
        <td>Diseño Atractivo de la Página de Inicio</td>
        <td>: Crear una página de inicio atractiva y funcional que proporcione un resumen claro de las características principales y los beneficios de SportEase.</td>
        <td>1 horas</td>
        <td>Mauricio</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US02</td>
        <td>Resumen de precios</td>
        <td>T02</td>
        <td>Información de Planes Detallada</td>
        <td>Proporcionar una descripción clara y detallada de los planes ofrecidos por SportEase para que los visitantes puedan tomar decisiones informadas.</td>
        <td>2 horas</td>
        <td>Moises</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US03</td>
        <td>Navegación rápida y fluida</td>
        <td>T03</td>
        <td>Experiencia de Navegación Optima</td>
        <td>Optimizar la navegación en la página de inicio para que los visitantes puedan acceder fácilmente a la información y tomar decisiones conscientes sobre el uso de la plataforma.</td>
        <td>1 hora</td>
        <td>Flavio</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US04</td>
        <td>Acceso rápido a las secciones clave</td>
        <td>T04</td>
        <td>Acceso Directo a Secciones Relevantes</td>
        <td>Implementar un menú de navegación claro en la página de inicio para que los visitantes puedan acceder rápidamente a las secciones clave de SportEase.</td>
        <td>1 hora</td>
        <td>Piero</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US05</td>
        <td>Descripción detallada de funcionalidades</td>
        <td>T05</td>
        <td>Detalles de Funcionalidades de SportEase</td>
        <td>Agregar una sección detallada que describa las funcionalidades de SportEase para que los visitantes comprendan cómo pueden beneficiarse de la plataforma.</td>
        <td>1 hora</td>
        <td>Mauricio</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US06</td>
        <td>Formulario de contacto</td>
        <td>T06</td>
        <td>Comunicación Directa con SportEase</td>
        <td>Incluir un formulario de contacto en la página de inicio para que los visitantes puedan comunicarse fácilmente con el equipo de SportEase y obtener más información sobre la plataforma.</td>
        <td>1 hora</td>
        <td>Moises</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US07</td>
        <td>Diseño responsivo para dispositivos moviles</td>
        <td>T07</td>
        <td>Experiencia Móvil Optima</td>
        <td>Adaptar el diseño de la página de inicio para que se vea correctamente en dispositivos móviles y brinde una experiencia de usuario óptima.</td>
        <td>2 horas</td>
        <td>Flavio</td>
        <td>Done</td>
    </tr>
    <tr>
        <td>US08</td>
        <td>Calls to action claro y efectivo</td>
        <td>T08</td>
        <td>Llamadas a la Acción Destacadas</td>
        <td>Diseñar llamadas a la acción claras y efectivas que guíen a los visitantes hacia los pasos necesarios para interactuar con SportEase.</td>
        <td>1 hora</td>
        <td>Piero</td>
        <td>Done</td>
    </tr>
        <td>US09</td>
        <td>Mejora de la interactividad</td>
        <td>T09</td>
        <td>Interacción Mejorada en la Página de Inicio</td>
        <td>Agregar elementos interactivos como animaciones y efectos visuales para mejorar la experiencia de usuario en la página de inicio de SportEase.</td>
        <td>1 hora</td>
        <td>Mauricio</td>
        <td>Done</td>
    </tr>
</table>

URL del Board en Trello: https://trello.com/b/NybJnMIm/open-source
![Board Trello](/assets/trello.png)

### 5.2.1.3 Development Evidence for Sprint Review.
Esta sección documenta y presenta la serie de commits realizados en el repositorio del Landing Page. Estos commits, que son una parte integral del proceso de desarrollo, se han gestionado utilizando la metodología GitFlow y siguiendo estrictamente las convenciones establecidas para los commits. Esta evidencia sirve como un registro transparente y trazable de nuestro progreso y esfuerzos de desarrollo a lo largo del sprint.

| Repository                                         | Branch                       | Commit Id                          | Commit Message                   | Commit Message Body               |Commited on (Date) |
|----------------------------------------------------|------------------------------|------------------------------------|----------------------------------|-----------------------------------|-------------------|
| upc-pre-202401-si729-sv54-sportease-landing-page   | main                         | 88ff68d                            | chore: ...                       | initial commit                    | 04/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | main                         | cb74182                            | chore: ...                       | create structure for landing      | 12/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-header       | 8a3a328                            | feat: ...                        | add header section                | 12/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-contact      | cf09f3f                            | feat: ...                        | add contact section               | 12/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-footer       | b55f787                            | feat: ...                        | add footer section                | 12/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-header       | 42440a2                            | feat: ...                        | add responsive design for desktop | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-suscription  | 78a41b2                            | feat: ...                        | add suscriptions section          | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-header       | 1d4cc00                            | feat: ...                        | add meta tags and seo tags        | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-functionalities | 9bed26e                         | feat: ...                        | add functionalities section       | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-functionalities | 5e513b2                         | fix : ...                        | correct speeling                  | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-functionalities | 7bfebde                         | feat: ...                        | add styles for                    | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-about-us     | aa1ac7d                            | feat: ...                        | add about us section              | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | 7d96968                            | merge                            | merge branch                      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | a7574a5                            | merge                            | merge branch                      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | 31ee1b8                            | merge                            | merge branch                      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | f3d8011                            | merge                            | merge branch                      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | 0486562                            | merge                            | merge branch                      | 13/04             |

![Lista de commits](/assets/commits.png)

### 5.2.1.4 Testing Suite Evidence for Sprint Review. 
En esta sección, presentamos la evidencia de las pruebas realizadas durante el sprint. Hemos utilizado Gherkin para definir los escenarios de prueba y hemos registrado cada prueba en commits específicos en nuestro repositorio. A continuación, se muestra un registro de estos commits:

| Repository                                         | Branch                       | Commit Id                          | Commit Message                   | Commit Message Body               |Commited on (Date) |
|----------------------------------------------------|------------------------------|------------------------------------|----------------------------------|-----------------------------------|-------------------|
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-header       | 2e1280d                            | feat: ...                        | add test for header section       | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-header       | f16eef1                            | feat: ...                        | add test for header section       | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-contact      | f4e985a                            | feat: ...                        | add test for contact section      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-suscriptions | cf09f3f                            | feat: ...                        | add test for contact section      | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-functionalities | 237c920                         | feat: ...                        | add test for functionalities feature | 13/04          |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-footer       | 3869f07                            | feat: ...                        | add test for footer section       | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | feature/section-about-us     | feb6528                            | feat: ...                        | add test for about-us section     | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | c4cfe38                            | feat: ...                        | add test for develop              | 13/04             |
| upc-pre-202401-si729-sv54-sportease-landing-page   | develop                      | 8a64c5e                            | feat: ...                        | add test for develop              | 13/04             |

### 5.2.1.5 Execution Evidence for Sprint Review. 

Durante el Sprint 1, se logró un progreso significativo en la implementación de las características clave de la página de inicio del sitio web. El equipo completó con éxito todas las historias de usuario asignadas para este sprint, que incluyeron el desarrollo de un resumen claro de las características y beneficios del sitio web, la integración de acceso visible a información detallada de precios, la adición de un resumen conciso al final de la página de inicio, la inclusión de un llamado a la acción prominente para dirigir a los visitantes a la aplicación web principal, la presentación de contenido informativo claro y detallado, y la integración de información de contacto visible en la página de inicio. El equipo trabajó de manera colaborativa para garantizar que las características implementadas cumplan con los requisitos y contribuyan a una experiencia de usuario positiva.

Capturas de pantalla:

- Página de Inicio

![Inicio](/assets/inicio.png)

- Resumen de precios

![Precios](/assets/precios.png)

- Acceso Rápido a las Secciones Clave

![Header](/assets/header.png)

- Descripción Detallada de Funcionalidades

![Funcionalidades](/assets/funcionalidades.png)

- Formulario de Contacto

![Contacto](/assets/contacto.png)

- Diseño Responsivo para Dispositivos Móviles:

![Responsive](/assets/responsive.png)

- Call to Action Claro y Efectivo

![Call-to-action](/assets/calltoaction.png)

Video: 

### 5.2.1.6 Services Documentation Evidence for Sprint Review. 

Durante este Sprint 1, nos enfocamos en desarrollar el landing page, sin implementación de cualquier servicio. Por lo tanto, este punto quedará sin actividad en este aspecto.

### 5.2.1.7 Software Deployment Evidence for Sprint Review.

Durante el Sprint 1, llevamos a cabo el despliegue de nuestra landing page en GitHub Pages. A continuación, detallamos los pasos realizados:

1. Primero creamos un repositorio en Github para el landing page

![Ramas](/assets/repo.png)

2. Las ramas necesarias se crean siguiendo el flujo de trabajo de GitFlow.

![Ramas](/assets/ramas.png) 

3. En la configuración del repositorio, se accede a la sección "Pages".

![Ramas](/assets/pages.png)

4. Se ajusta la configuración para indicar la fuente de la landing page.

![Ramas](/assets/fuente.png)

5. Después de guardar la configuración, se genera un enlace para acceder a la landing page.

![Ramas](/assets/enlace.png)

6. Este enlace permite visualizar las actualizaciones realizadas en la rama "develop".

![Ramas](/assets/link.png)

### 5.2.1.8 Team Collaboration Insights during Sprint.

Durante este primer Sprint, hemos completado el desarrollo del landing page y hemos colaborado estrechamente en su implementación. La colaboración entre los miembros del equipo se refleja en los diversos commits realizados en el repositorio de GitHub, los cuales han sido debidamente documentados en las capturas de pantalla adjuntas.
Para asegurar una colaboración efectiva, hemos implementado GitFlow como nuestra metodología de trabajo colaborativo en Git. Con GitFlow, hemos creado ramas para cada una de las secciones de nuestra landing page. Esto nos ha permitido trabajar de manera organizada y centrarnos en completar correctamente las historias de usuario designadas para cada sección.
En cuanto a la elaboración del código, hemos asignado a cada miembro del equipo una sección específica del landing page. Esta estrategia nos ha permitido avanzar de manera más eficiente y completar el trabajo antes de la fecha de entrega.
Además, hemos realizado reuniones adicionales para intercambiar ideas y resolver cualquier duda o problema que pudiera surgir durante el desarrollo del landing page. Estas sesiones han contribuido de manera positiva al éxito del proyecto.
A continuación, presentamos algunas capturas de pantalla que muestran los commits realizados por los miembros del equipo en GitHub:
![Ramas](/assets/ramas.png)

![Mauricio](/assets/mauricio.png)

![Piero](/assets/piero.png)

![Flavio](/assets/flavio.png)

![Moises](/assets/moises.png)
